{
    "collab_server" : "",
    "contents" : "############################################################\n# Supporting functions file for the Innovatos 2017 demo app\n\n# Date: 08-Mar-2017\n# Author: Marcel van den Bosch <marcel.vandenbosch@atos.net>\n############################################################\n\nlibrary(sm)\nlibrary(pastecs)\nlibrary(DMwR)\nlibrary(corrplot)\nlibrary(caret)\nlibrary(xgboost)\n\noptions(scipen=100)\noptions(digits=2)\noptions(shiny.maxRequestSize=30*1024^2)\n#datadir <- 'secom_dataset';\n\n\n#loadData <- function()\n#{\n # write.t\n  #data <- read.csv(\"file\")\n  #data <<- read.csv(paste0(getwd(),'/',datadir,'/','secom.data'),sep=' ',header=F);\n  \n#  names(data) <<- paste0('MEAS_',rep(1:ncol(data)));\n  \n # data.labels <<- read.csv(paste0(getwd(),'/',datadir,'/','secom_labels.data'),sep=' ',header=F);\n#  names(data.labels) <<- c('FAIL','TIMESTAMP');\n  \n # data <<- cbind(data.labels,data);\n  \n#  data$FAIL[data$FAIL == -1] <- 'OK';\n # data$FAIL[data$FAIL == 1] <- 'FAIL';\n  \n  #data$FAIL <<- as.factor(data$FAIL);\n  \n  #data$TIMESTAMP <<- as.POSIXct(strptime(data$TIMESTAMP, \"%d/%m/%Y %H:%M:%S\"))\n\n#}\n\n\nloadData1 <- function(file1,header,sep,quote)\n{\n  data <- read.csv(file1,header=header,sep = sep,quote = quote)\n  #data$FAIL <<- as.factor(data$FAIL)\n  \n #data$TIMESTAMP <<- as.POSIXct(strptime(data$TIMESTAMP, \"%d/%m/%Y %H:%M:%S\"))\n  return(data)\n}\n\n\n#factor_column <- function()\n#{\n#  for(i in 1:length(data))\n#  {\n#    a <- paste0(\"V\",i)\n#    data[,i] <- as.factor(data[,i])\n#    if(nlevels(data[,i])==2)\n#    {\n#      return(a)\n#    }\n#  }\n#  print(a)\n#}\n\n\nall_column <- function()\n{\n  allcolumn <- names(data)\n}\n\n\n\nplotDensity <- function(colname,colname1)\n{\n  \n  data_value <- subset(copy(data),select=c(colname,colname1));\n  names(data_value) <- c(colname,colname1);\n  data_value <- na.omit(data_value);\n  \n  par(mfrow=c(2,1));\n  hist(data_value[,colname1],xlab=paste(\"Value:\",colname),main = 'Histogram',xlim=c(min(data_value[,colname1]),max(data_value[,colname1])));\n  sm.density.compare(as.numeric(data_value[,colname1]),group = data_value[,colname], xlab=paste(\"Value:\",colname),xlim=c(min(data_value[,colname1]),max(data_value[,colname1])));\n  title(\"Density compare\");\n  legend(\"topright\",levels(as.factor(data_value[,colname])), fill=c(2:(2+length(levels(as.factor(data_value[,colname]))))),cex=1);\n  \n  \n}\n\n\nplotCaseStats <- function(col_name)\n{\n  yVar <<- col_name;\n  print(\"Before factor\")\n  data[,col_name] <- as.factor(data[,col_name])\n  print(\"After factor\")\n  out <- table(data[,col_name])\n  \n  linch <-  max(strwidth(out, \"inch\")+0.7, na.rm = TRUE)\n  par(mai=c(1.02,linch,0.82,0.42))\n  x <- barplot(out,horiz = TRUE,cex.names=0.9,las=1,xlab=paste(\"# of Wafers\"),xlim=c(0,max(out,na.rm=TRUE)+50),col=\"cornflowerblue\")\n  text(out+pmin((5+out*0.7),20),x,labels=round(out), col=\"black\",cex=0.75)\n  \n}\n\n\ncreateSummaryTable <- function()\n{\n  \n  data_value <- copy(data[,3:ncol(data)]);\n  \n  return(t(stat.desc(data_value)))\n\n}\n\nplotCorrGram <- function(no_cols)\n{\n  \n  # Exclude timestamp and FAIL, as they are not  numerical\n  v1 <- c()\n  for(i in 1: length(data))\n  {\n    \n    if(class(data[,i]) == 'integer' || class(data[,i]) == 'numeric' )\n    { \n      \n      v1 <-  c(v1,names(data[i]))\n      #print(v1)\n      \n    }\n    \n  }\n  data_value <- subset(copy(data),select=v1);\n  \n  \n  columns.to.keep<-names(which(colMeans(is.na(data_value)) < 0.5)) # this removes those columns with more than 50% NULLs\n  data_value<-subset(data_value,select = columns.to.keep) #the columns will stay which has less than 50% NAs\n  \n  #nzv <- nearZeroVar(data_value)\n  #data_value <- data_value[,-nzv]\n  \nif (no_cols > ncol(data_value))\n {\n   no_cols <- ncol(data_value);\n }\n  \n  data_value <-  data_value[,1:no_cols];\n  \n  M <- cor(data_value,use = 'pairwise.complete.obs')\n  col3 <- colorRampPalette(c(\"red\", \"white\", \"blue\")) \n  corrplot(M, method=\"color\",col = col3(20),tl.col=\"black\",na.label=\" \",tl.cex=0.5)\n  \n}\n\n\n\n\n\n\n\n\nfindTop100Features <- function(input_data,target_variable,SMOTE_BALANCE = TRUE, USE_RF = TRUE, USE_XGBOOST = TRUE, NO_RF_TREES = 500, RETURN_VAR_VECTOR = TRUE)\n{\n  # Description: Re-usable helper function to easily find relevant parameters in a dataset\n  # Author: Marcel van den Bosch <marcel.vandenbosch@atos.net>\n  \n  # Find the TOP100 most interesting features using RandomForest & XGBoost and return it as a list of names\n  \n  # Smote only works with factor/numerics\n  relevant_cols <- names(input_data)[unlist(lapply(seq(1:length(names(input_data))), function(x)  { if(paste(class(input_data[,x]),collapse=' ') %in% c('numeric','factor')) { return(x)} else { return(NULL)} } ))];\n  data_balanced <- subset(input_data,select=relevant_cols);\n  \n  if (SMOTE_BALANCE == TRUE)\n  {\n    data_balanced <-SMOTE(form = FAIL ~., data = data_balanced, perc.over = 500,perc.under = 120)\n  } \n  \n  # Split out the data with target and input features\n  data_balanced.target <- subset(data_balanced,select=target_variable);\n  data_balanced.input <- subset(data_balanced,select=setdiff(names(data_balanced),target_variable));\n  \n  data_balanced.target.zero.one<-as.matrix(ifelse(data_balanced.target=='FAIL',yes=1,no=0))\n  \n  if (USE_XGBOOST == TRUE)\n  {\n  bst <- xgboost(data = as.matrix(data_balanced.input), label = data_balanced.target.zero.one, max_depth = 15,\n                 eta = 0.1, nthread = 5, nrounds = 200,objective = \"reg:logistic\",  missing = NaN )\n  \n  # Now calculating the predictor importance\n  importanceRaw <- xgb.importance(feature_names = colnames(data_balanced.input), model = bst, data = as.matrix(data_balanced.input), label = data_balanced.target.zero.one)\n  \n  #putting the data into dataframes\n  importance.xgboost<-data.frame(importanceRaw$Feature,importanceRaw$Gain)\n  importance.xgboost <- importance.xgboost[order(-importance.xgboost$importanceRaw.Gain),] #sorting the importances based on the gain\n  \n  importance.XG <- data.frame(Variable=importance.xgboost$importanceRaw.Feature[1:100],Importance=importance.xgboost$importanceRaw.Gain[1:100],Rank=seq(1:100),Type='XGBoost');\n  }\n  \n  if (USE_RF == TRUE)\n  {\n    data_balanced <- rfImpute(FAIL ~ ., data=data_balanced, iter=3, ntree=50)\n    \n    fit.rf =randomForest(FAIL ~., data=data_balanced,importance=TRUE,ntree=NO_RF_TREES)\n    \n    importance.randomForest<-data.frame(row.names(varImp(fit.rf)),varImp(fit.rf))\n    names(importance.randomForest)<-c(\"Variable\",\"importanceRaw.Gain\")\n    importance.randomForest <- importance.randomForest[order(-importance.randomForest$importanceRaw.Gain),]\n    \n    importance.RF <- data.frame(Variable=importance.randomForest$Variable[1:100],Importance=importance.randomForest$importanceRaw.Gain[1:100],Rank=seq(1:100),Type='RF');\n  }\n  \n  if (USE_RF == TRUE && USE_XGBOOST == TRUE)\n  {\n    # UNION/Rbind results\n    result <- union(importance.xgboost$importanceRaw.Feature[1:100],importance.randomForest$Variable[1:100]);\n    importance.ALL <- rbind(importance.XG,importance.RF)\n  } else if (USE_RF == TRUE)\n  {\n    result <- importance.randomForest$Variable[1:100];\n    importance.ALL <- importance.RF;\n  } else if (USE_XGBOOST == TRUE)\n  {\n    result <- importance.xgboost$importanceRaw.Feature[1:100];\n    importance.ALL <- importance.XG;\n  }\n  \n\n  if (RETURN_VAR_VECTOR == TRUE)\n  {\n    return(result[1:100]);\n    \n  } else {\n    \n    importance.ALL <- importance.ALL[order(importance.ALL$Rank),];\n    row.names(importance.ALL) <- NULL;\n    return(head(importance.ALL,100));\n  }\n  \n  \n}\n\n\n\n\n",
    "created" : 1505306568747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4227532490",
    "id" : "7B63E78E",
    "lastKnownWriteTime" : 1505307326,
    "last_content_update" : 1505307326768,
    "path" : "C:/Users/A672257/Desktop/Siddhant/AtosInnovatos2017-master/functions.R",
    "project_path" : "functions.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}