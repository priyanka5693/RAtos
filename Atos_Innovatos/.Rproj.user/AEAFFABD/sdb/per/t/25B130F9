{
    "collab_server" : "",
    "contents" : "# Load required libraries (please install them with install.packages()  if missing )\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(shinyjs)\nlibrary(data.table)\nlibrary(DT)\nlibrary(rpart)\nlibrary(rattle)\nlibrary(randomForest)\nlibrary(sampling)\nlibrary(e1071)\nlibrary(caTools)\nlibrary(dplyr)\nlibrary(tools)\n# Include helper files\nsource('functions.R')\n\n# Add URL prefix for loading additional resource, such as images\naddResourcePath('resources',\"www\")\n\n# Custom ShinyJS hack code to let the boxes collapse automatically\njscode <- \"shinyjs.collapse = function(boxid) { $('#' + boxid).closest('.box').find('[data-widget=collapse]').click(); }\";\n\n# Define variables for having the datasat globally\nassign(\"data\", NULL, envir = .GlobalEnv);\n\n\nserver <- function(input, output,session) {\n  \n\n \n  observe({\n\n    \n    # For performance reasons, only execute if the tab is actually opened by the user.\n    # Logic behind the data table overview tab\n    suppressWarnings(if(input$tab == \"Upload\")\n    {\n      \n      observeEvent(input$btnUpload, {\n       \n        ##########################################\n        output$validation <- renderPrint({\n          data <<- NULL;\n        File <- input$file1        \n        #catches null exception\n        if (is.null(File))\n          return(NULL)\n        \n        validate(\n          need(file_ext(File$name) %in% c(\n            'text/csv',\n            'text/comma-separated-values',\n            'text/tab-separated-values',\n            'text/plain',\n            'csv',\n            'tsv'\n          ),\"Wrong File Format!!! \\n Please upload a csv file\"))\n        data <<- loadData1(input$file1$datapath,header = input$header,sep = input$sep, quote = input$quote);\n        })\n        ##########################################\n       \n      })\n      \n    }\n    )\n    \n    \n    if (input$tab == 'Data')\n    {\n      # input$file1 will be NULL initially. After the user selects\n      # and uploads a file, head of that data file by default,\n      # or all rows if selected, will be shown.\n      if(is.null(data))\n      {\n        output$dat <- renderText({\n          validate(\n            need(data != \"\",  shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n      if(!is.null(data))\n      {\n      output$contents <- renderDataTable({\n      datatable(data, options = list(scrollX = TRUE,pageLength = 10))\n      })\n     \n   \n      output$DataSelectInput <- renderUI({\n        dataNames <- all_column()\n        selectInput(\"datacat\", \"Choose Option:\",dataNames) \n      })\n      observeEvent(input$btnCatData, {\n       # yVar <<- input$datacat;\n      #  data[,yVar] <<- as.factor(data[,yVar]);\n     # )}\n      values <- reactiveValues()\n     values$name <- input$datacat;\n      observeEvent(input$BUTyes, {\n        toggleModal(session, \"modalnew\", toggle = \"close\")\n        yVar <<- values$name;\n        data[,yVar] <- as.factor(data[,yVar])\n      })\n      \n      observeEvent(input$BUTno, {\n        toggleModal(session, \"modalnew\", toggle = \"close\")\n        updateTextInput(session, \"newName\", value=values$name)\n      })\n      \n      session$sendCustomMessage(type = 'resetInputValue', message =  \"btnCatData\")\n      \n      }\n      )}\n    }\n    \n    \n    # Logic behind the summary statistcs tab\n    if (input$tab == 'ExploreSummary')\n    {\n      if(is.null(data))\n      {\n        output$exp <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n      if(!is.null(data))\n      {\n      output$dtSummary = renderDataTable({\n        datatable(suppressWarnings(suppressWarnings(createSummaryTable())), options = list(scrollX = TRUE,pageLength = 20))\n        \n      })\n      }\n    }\n    \n    # Logic behind the density compare tab\n    if (input$tab == 'ExploreDensity')\n    {\n    \n      if(is.null(data))\n      {\n        output$den <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n      output$densitySelectInput2 <- renderUI({\n        dataNames <- all_coloumn1()\n        selectInput(\"column\", \"Choose Option:\",dataNames ) \n      })\n      if(!is.null(data))\n      {\n      output$DensityPlot <- renderPlot({ suppressWarnings(plotDensity(yVar,input$column)) });\n      }\n    }\n    \n    if (input$tab == 'ExploreCorrelation')\n    {\n      if(is.null(data))\n      {\n        output$cor <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n      if(!is.null(data))\n      {\n      output$CorrelogramPlot <- renderPlot({ \n        suppressWarnings(plotCorrGram(input$intNoCorrVars))\n        \n      });\n      }\n    }\n    \n    # Logic behind the case stats overview tab\n    if (input$tab == 'CaseOverview')\n    {\n     \n      if(is.null(data))\n      {\n        output$cas <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n      if(!is.null(data))\n      {\n        output$CaseStatsPlot <- renderPlot({ suppressWarnings(plotCaseStats(yVar)) }); \n      }\n       \n   \n    }\n  \n    if(input$tab == 'Rebalance')  \n    {\n      if(is.null(data))\n      {\n        output$reb <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n    }\n  })\n  \n \n  observeEvent(input$btnRunSMOTE, {\n    if(!is.null(data))\n    {\n    data[,yVar] <- as.factor(data[,yVar])\n    data_old <- data\n    v1 <- c()\n    for(i in 1: length(data_old))\n    {\n      \n      if(class(data_old[,i]) == 'integer' || class(data_old[,i]) == 'numeric')\n      { \n        \n        v1 <-  c(v1,names(data_old[i]))\n        \n      }\n    }\n    \n    v1 <- c(v1,yVar)\n    \n    \n    data_old <- subset(data_old,select=v1);\n    table(data[,yVar]) #Statistics before \n    names(data_old)[names(data_old) == yVar] <- \"yVar\"\n    data_balanced <- SMOTE(form = yVar ~ ., data = data_old, perc.over = 500, perc.under = 120)\n    names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n    names(data_old)[names(data_old) == \"yVar\"] <- yVar\n    output$Plot_SMOTE_Old_CaseStats <- renderPlot({ \n      out <- table(data[,yVar])\n      linch <-  max(strwidth(out, \"inch\")+0.7, na.rm = TRUE)\n      par(mai=c(1.02,linch,0.82,0.42))\n      x <- barplot(out,horiz = TRUE,cex.names=0.9,las=1,xlab=paste(\"# of cases\"),xlim=c(0,max(out,na.rm=TRUE)+50),col=\"cornflowerblue\",main = 'Before SMOTE')\n      text(out+pmin((5+out*0.7),20),x,labels=round(out), col=\"black\",cex=0.75)\n      \n    })\n    \n    output$Plot_SMOTE_New_CaseStats <- renderPlot({ \n      \n      out <- table(data_balanced[,yVar])\n      linch <-  max(strwidth(out, \"inch\")+0.7, na.rm = TRUE)\n      par(mai=c(1.02,linch,0.82,0.42))\n      x <- barplot(out,horiz = TRUE,cex.names=0.9,las=1,xlab=paste(\"# of cases\"),xlim=c(0,max(out,na.rm=TRUE)+50),col=\"cornflowerblue\",main = 'After SMOTE')\n      text(out+pmin((5+out*0.7),20),x,labels=round(out), col=\"black\",cex=0.75)\n      \n    })\n    \n    output$dtSMOTEresult = renderDataTable({\n      datatable(data_balanced, options = list(scrollX = TRUE,pageLength = 20))\n    })\n    \n    # Call our custom box collapse hack\n    js$collapse(\"Box_SMOTE_CaseStats1\")\n    js$collapse(\"Box_SMOTE_Dataset\")\n    }\n  })\n  \n\n  \n  \n  \n  \n  observeEvent(input$btnRunRPart, {\n    if(is.null(data))\n    {\n      output$rpa <- renderText({\n        validate(\n          need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n        )})\n    }\n    # Code below implements the decision tree functionality\n   if(!is.null(data))\n   {\n     isolate({\n       data[,yVar] <- as.factor(data[,yVar])\n      \n      if (input$chkRPartWithSMOTE == TRUE )\n      {\n      ####pasted part\n        \n      \n        data_old <- data\n        v1 <- c()\n        for(i in 1: length(data_old))\n        {\n          \n          if(class(data_old[,i]) == 'integer' || class(data_old[,i]) == 'numeric')\n          { \n            \n            v1 <-  c(v1,names(data_old[i]))\n            \n          }\n        }\n        \n        v1 <- c(v1,yVar)\n        \n        \n        data_old <- subset(data_old,select=v1);\n        table(data[,yVar]) #Statistics before \n        names(data_old)[names(data_old) == yVar] <- \"yVar\"\n        data_balanced <- SMOTE(form = yVar ~., data = data_old, perc.over = 500,perc.under = 120)\n        names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n        names(data_old)[names(data_old) == \"yVar\"] <- yVar\n      } else {\n        data_balanced <-data.table(copy(data))\n      }\n      \n      \n      # grow tree \n      names(data_balanced)[names(data_balanced) == yVar] <- \"yVar\"\n      fit <- rpart(yVar ~ .,\n                   method=\"class\", data=data_balanced, control=rpart.control(minsplit=2))\n      names(fit)[names(fit) == \"yVar\"] <- yVar\n      names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n      \n      output$Out_rpart = renderPrint({\n        summary(fit)\n      })\n      \n      \n      output$Plot_rpart = renderPlot({\n        fancyRpartPlot(fit,main=\"Decision Tree\",digits=10)\n      })\n      \n    })\n   }\n    js$collapse(\"Box_RPart_Results_plot\");\n    js$collapse(\"Box_RPart_Results_summary\");\n    \n  })\n  \n  \n  observeEvent(input$btnRunRF, {\n    # Below code implements the RandomForest modelling functionality\n    #data[,yVar] <- as.factor(data[,yVar])\n    if(is.null(data))\n    {\n      output$rfm <- renderText({\n        validate(\n          need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n        )})\n    }\n    \n    if (input$chkRPartWithSMOTE == TRUE )\n    {\n      \n        data[,yVar] <- as.factor(data[,yVar])\n    isolate({\n      \n      \n      if (input$chkRFWithTest == TRUE)\n      {\n        # Do a 75/25 split\n        sample = sample.split(data[,yVar], SplitRatio = .75)\n        data_train = subset(copy(data), sample == TRUE)\n        data_test = subset(copy(data), sample == FALSE)\n      } else {\n        # Just make both sets the same\n        data_train <- copy(data);\n        data_test <- copy(data);\n      }\n      \n      \n      if (input$chkRFWithSMOTE == TRUE )\n      {\n        data_old <- data_train\n       \n        #######\n\n        v1 <- c()\n        for(i in 1: length(data_old))\n        {\n          \n          if(class(data_old[,i]) == 'integer' || class(data_old[,i]) == 'numeric')\n          { \n            \n            v1 <-  c(v1,names(data_old[i]))\n            \n          }\n        }\n        \n        v1 <- c(v1,yVar)\n       \n\n        data_old <- subset(data_old,select=v1);\n        \n        print(yVar)\n        table(data[,yVar]) #Statistics before \n        print(table(data[,yVar]))\n        \n        names(data_old)[names(data_old) == yVar] <- \"yVar\"\n        data_balanced <- SMOTE(form = yVar ~., data = data_old, perc.over = 500,perc.under = 120)\n        names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n        names(data_old)[names(data_old) == \"yVar\"] <- yVar\n      } else {\n        data_balanced <- data_train #speeding up by turning into data.table\n      }\n      \n      columns.to.keep<-names(which(colMeans(is.na(data_balanced)) < 0.5)) # this removes those columns with more than 50% NULLs\n      data_balanced<-subset(data_balanced,select = columns.to.keep) #the columns will stay which has less than 50% NAs\n      \n\n      if (input$chkRFWithImpute == TRUE )\n      {\n        # Since RandomForest cannot handle missing values, we will try to impute them\n        names(data_balanced)[names(data_balanced) == yVar] <- \"yVar\"\n        test1.nona <- data_balanced[ , colSums(is.na(data_balanced)) != 0]\n        \n        if(ncol(test1.nona) > 0)\n        {\n        data.imputed <- rfImpute(yVar ~ ., data=data_balanced, iter=2, ntree=30)\n        }else{\n          data.imputed <- data_balanced;\n        }\n        names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n        names(data.imputed)[names(data.imputed) == \"yVar\"] <- yVar\n        \n        \n      } else {\n        \n        # The very cheap version of setting the missing values to something very high\n        data.imputed <- data_balanced;\n        data.imputed[is.na(data.imputed)]<--9999 #just some random number that never happened in the data\n      }\n      \n      #### Random Forest\n      names(data.imputed)[names(data.imputed) == yVar] <- \"yVar\"\n      \n      fit <- randomForest(yVar ~ .,\n                          data=data.imputed, \n                          importance=TRUE, \n                          ntree=input$intNoOfRF)\n      names(data.imputed)[names(data.imputed) == \"yVar\"] <- yVar\n      names(fit)[names(fit) == \"yVar\"] <- yVar\n      \n      output$plot_rf_varimp1 = renderPlot({\n        varImpPlot(fit,type=1,main = \"Variable Importance\")\n      })\n      \n      output$plot_rf_varimp2 = renderPlot({\n        varImpPlot(fit,type=2,main = \"Variable Importance\")\n      })        \n      \n      output$plot_rf_error = renderPlot({\n        plot(fit,main = \"Error\")\n      })\n      \n      \n      test_data <- data_test\n      test_result <- test_data[,yVar] # Make sure we have the results seaprate\n      \n      pred_data <- predict(object = fit, newdata = test_data)\n      \n      xtab <- table(pred_data, test_result)\n      \n      output$Out_rf = renderPrint({\n        confusionMatrix(xtab)\n      })\n      \n      \n    })\n      }\n\n    js$collapse(\"Box_RF_Results_plot\");\n    js$collapse(\"Box_RF_Results_conf\");\n    \n    \n  })\n  \n  ###########remaining\n  \n  observeEvent(input$btnRunFeature, {\n    # Code below calls the function to find the TOP100 most promising features\n    data[,yVar] <- as.factor(data[,yVar])\n    output$FeatureTable = renderDataTable({\n      if(is.null(data))\n      {\n        output$fea <- renderText({\n          validate(\n            need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n          )})\n      }\n\n        if(!is.null(data))\n        {\n      isolate({\n        datatable(suppressWarnings(findTop100Features(copy(data),input$intNoCorrVars1))) \n      })\n        }\n    })\n    \n    \n  })\n  \n  \n  observeEvent(input$btnRunSVM, {\n    # This code implements the SVM modelling functionality\n    if(is.null(data))\n    {\n      output$svm <- renderText({\n        validate(\n          need(data != \"\", shinyjs::alert(\"Please select a data set\")) \n        )})\n    }\n    if(!is.null(data))\n    {\n      data[,yVar] <- as.factor(data[,yVar])\n    \n      isolate({\n        v1 <- c()\n        data_old <- data\n        for(i in 1: length(data_old))\n        {\n          \n          if(class(data_old[,i]) == 'integer' || class(data_old[,i]) == 'numeric')\n          { \n            \n            v1 <-  c(v1,names(data_old[i]))\n            #print(v1)\n            \n          }\n        }\n        \n        v1 <- c(v1,yVar)\n        data_old <- subset(data_old,select=v1);\n        \n        ######################\n        if (input$chkSVMWithTest == TRUE)\n        {\n          # Do a 75/25 split\n          \n          \n         \n          \n          \n          \n          sample = sample.split( data_old[,yVar], SplitRatio = .75)\n          data_train = subset(copy(data_old), sample == TRUE)\n          data_test = subset(copy(data_old), sample == FALSE)\n        } else {\n          # Just make both sets the same\n          data_train <- copy(data_old);\n          data_test <- copy(data_old);\n        }\n        \n        if (input$chkSVMWithTOPFeatures == TRUE)\n        {\n          top100_cols <- findTop100Features(data_train,input$intNoCorrVars2);\n          \n          top100_cols <- as.vector(top100_cols[,1])\n        }\n        \n        if (input$chkSVMWithSMOTE == TRUE )\n        {\n          \n         \n          \n          \n          \n          print(yVar)\n          table(data[,yVar]) #Statistics before \n          print(table(data[,yVar]))\n          \n          names(data_old)[names(data_old) == yVar] <- \"yVar\"\n          data_balanced <- SMOTE(form = yVar ~., data = data_old, perc.over = 500,perc.under = 120)\n          \n          names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n          \n          names(data_old)[names(data_old) == \"yVar\"] <- yVar\n        } else {\n          data_balanced <- data_train \n          #data_balanced <- subset(data_balanced,select=-TIMESTAMP);\n        }\n        \n        if (input$chkSVMWithTOPFeatures == TRUE)\n        {\n          data_balanced <- subset(data_balanced,select=c(top100_cols,yVar));\n        }\n        \n        columns.to.keep<-names(which(colMeans(is.na(data_balanced)) < 0.5)) # this removes those columns with more than 50% NULLs\n        data_balanced<-subset(data_balanced,select = columns.to.keep) #the columns will stay which has less than 50% NAs\n        \n        \n        names(data_balanced)[names(data_balanced) == yVar] <- \"yVar\"\n        test1.nona <- data_balanced[ , colSums(is.na(data_balanced)) != 0]\n        \n        if(ncol(test1.nona) > 0)\n        {\n          data_balanced <- rfImpute(yVar ~ ., data=data_balanced, iter=2, ntree=30)\n        }else{\n          data_balanced <- data_balanced;\n        } \n        \n        names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n        \n        nzv <- nearZeroVar(data_balanced)\n        if(length(nzv) > 0)\n        {\n          data_balanced <- data_balanced[,-nzv]\n        }\n        \n        data_balanced[is.na(data_balanced)]<--9999\n        names(data_balanced)[names(data_balanced) == yVar] <- \"yVar\"\n        xData <- subset(data_balanced,select=-yVar);\n        names(data_balanced)[names(data_balanced) == \"yVar\"] <- yVar\n        #names(xData)[names(xData) == \"yVar\"] <- yVar\n        yData <- data_balanced[,yVar];\n      \n        fit.svm<-svm(x = xData,y= yData)\n        \n        \n        # Get our test set from the original split\n        test_data <- data_test\n        test_result <- test_data[,yVar]; # Make sure we have the results seaprate - as some functions like it separate\n        \n        # Remove the target and timestamp\n        \n        names(test_data)[names(test_data) == yVar] <- \"yVar\"\n        test_data <- subset(test_data,select=-yVar);\n        names(test_data)[names(test_data) == \"yVar\"] <- yVar\n        #test_data <- subset(test_data,select=-FAIL)\n        \n        # NA's are not desired, as it hinders prediction.\n        test_data[is.na(test_data)]<--9999 #just some random number that never happened in the data\n        \n        if (input$chkSVMWithTOPFeatures == TRUE)\n        {\n          test_data<-subset(test_data,select = c(top100_cols));\n        }\n        \n        test_data<-subset(test_data,select = setdiff(columns.to.keep,yVar)) #the columns will stay which has less than 50% NAs\n        if(length(nzv) > 0)\n        {\n          test_data <- test_data[,-nzv]\n        }\n        \n        # Do the actual prediction with our previously trained model\n        pred_data <- predict(object = fit.svm, newdata = test_data)\n        \n        xtab <- table(pred_data, test_result)\n        data <- data\n        # Write results back to the app\n        output$Out_svm = renderPrint({\n          isolate({\n            cat(\"Started with options:\\r\\n\")\n            cat(\"* SMOTE : \", input$chkSVMWithSMOTE,\"\\r\\n\")\n            cat(\"* TOP100 Features : \",input$chkSVMWithTOPFeatures,\"\\r\\n\")\n            cat(\"* TEST/TRAINING SET : \",input$chkSVMWithTest,\"\\r\\n\")\n            cat(\"---------------------------------------------------------\\r\\n\")\n            confusionMatrix(xtab)\n          })\n        })\n        ####################\n        \n        \n        \n \n        })\n      }\n    })\n}\n",
    "created" : 1505389810288.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "832176302",
    "id" : "25B130F9",
    "lastKnownWriteTime" : 1505966726,
    "last_content_update" : 1505966726978,
    "path" : "C:/Users/A664134/Downloads/final_task/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}